const { Op, Sequelize } = require('sequelize');
const { Lot, Offer, Deal, Auction, AuctionParticipant, User, UserInfo } = require('../models');
const cron = require('node-cron');
const dayjs = require('dayjs');
const utc = require('dayjs/plugin/utc');
const timezone = require('dayjs/plugin/timezone');
const sequelize = require('../config/database');

dayjs.extend(utc);
dayjs.extend(timezone);



exports.createAuction = async (createAuction, user_id) => {
  try {
    const auction = await Auction.create({ user_id, ...createAuction });
    return auction
  } catch (err) {
    throw new Error(JSON.stringify({ message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∞—É–∫—Ü–∏–æ–Ω–∞', error: err.message }));
  }
};

exports.scheduledLots = () => {
  cron.schedule('* * * * *', async () => {
const bishkekTime = dayjs().tz('Asia/Bishkek');
const now = bishkekTime.toDate();
console.log('üü¢ formatted', now.toISOString()); // –Ω–∞–ø—Ä–∏–º–µ—Ä: 2025-06-26 10:50:00.000+06:00
// console.log('üü¢ scheduledLots', );

    try {
      // –ò—â–µ–º –∞—É–∫—Ü–∏–æ–Ω—ã —Å –∏—Å—Ç–µ–∫—à–∏–º —Å—Ä–æ–∫–æ–º
      const auctions = await Auction.findAll({
        where: {
          status: 'open',
          closing_type: 'auto',
          end_time: { [Op.lte]: now }
        },
        include: [{
          model: Lot,
          as: 'lots',
          required: false,
          where: { status: 'open' },
          include: [{
            model: Offer,
            where: { status: 'pending' },
            as: 'offers',
            separate: true,
            order: [['percent', 'DESC']],
          }]
        }]
      });
      console.log('üü¢ auctions', auctions.length);
      for (const auction of auctions) {
        for (const lot of auction.lots) {
          const offers = lot.offers;

          if (!offers.length) continue;
          const maxPercent = offers[0].percent;
          const topOffers = offers.filter(offer => offer.percent === maxPercent);
          // –ï—Å–ª–∏ –±–æ–ª—å—à–µ 2-—Ö –ª–∏–¥–µ—Ä–æ–≤ ‚Äî –ø–µ—Ä–µ–≤–æ–¥–∏–º –≤ —Ä—É—á–Ω–æ–π —Ä–µ–∂–∏–º
          if (topOffers.length >= 2) {
            auction.closing_type = 'manual';
          }

          // –ï—Å–ª–∏ —Ä–æ–≤–Ω–æ 1 –ª–∏–¥–µ—Ä ‚Äî –¥–æ–±–∞–≤–ª—è–µ–º –≤ –ø–æ–±–µ–¥–∏—Ç–µ–ª–∏
          else if (topOffers.length === 1) {
            const winner = topOffers[0];
            auction.status = 'finished';
            lot.status = 'finished';
            winner.status = 'accepted';
              // –í—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –∑–∞—è–≤–∫–∏ ‚Äî rejected
            for (const offer of offers) {
              if (offer.id !== winner.id) {
                offer.status = 'rejected';
                await offer.save();
              }
            }
            await Deal.create({
              auction_id: auction.id,
              lot_id: lot.id,
              offer_id: winner.id,
              percent: winner.percent,
              user_id: winner.user_id,
              amount: lot.volume
            });
            await lot.save()
            await winner.save();
          }
        }
        await auction.save();
      }
    } catch (err) {
      console.error('[CRON ERROR]:', err.message);
    }
  });
};


exports.getAuctions = async (user_id) => {
  try {
    const auctions = await Auction.findAll({
      order: [['createdAt', 'DESC']],
      include: [{
        model: Lot,
        as: 'lots'
      }]
    });
    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∑–∞–ø–∏—Å–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞
    const participantRecords = await AuctionParticipant.findAll({
      where: {
        user_id,
        status: 'approved', // —Ç–æ–ª—å–∫–æ –æ–¥–æ–±—Ä–µ–Ω–Ω—ã–µ
      },
    });

    const accessMap = new Set(participantRecords.map(p => p.auction_id));

    // –î–æ–±–∞–≤–ª—è–µ–º —Ñ–ª–∞–≥ –¥–æ—Å—Ç—É–ø–∞
    const result = auctions.map(auction => {
      return {
        ...auction.toJSON(),
        has_access: accessMap.has(auction.id)
      };
    });

    return result
  } catch (err) {
    throw new Error(JSON.stringify({ message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∞—É–∫—Ü–∏–æ–Ω–æ–≤', error: err.message }));
  }
};

exports.getAuctionLots = async (auction_id) => {
  try {
    const lotsWithOffers = await Lot.findAll({
      where: { auction_id },
      include: [
        {
          model: Offer,
          as: 'offers',
          include: [
            {
              model: User,
              as: 'user',
              attributes: ['id', 'name', 'email'],
            }
          ],
        },
      ],
      order: [['createdAt', 'ASC']],
    });
    console.log('üü¢ lotsWithOffers', lotsWithOffers)
    return lotsWithOffers;
  } catch (err) {
    throw new Error(JSON.stringify({ message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π', error: err.message }));
  }
};

exports.getAuctionSelfOffer = async (auction_id, user_id) => {
  try {
    const lots = await Lot.findAll({
      where: { auction_id },
      include: [
        {
          model: Offer,
          as: 'offers',
          where: { user_id },
          required: false, // —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å –ª–æ—Ç—ã –¥–∞–∂–µ –±–µ–∑ –∑–∞—è–≤–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        },
      ],
      order: [['createdAt', 'ASC']],
    });

    return lots;
  } catch (err) {
    throw new Error(JSON.stringify({ message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π', error: err.message }));
  }
};

exports.joinAuction = async (auction_id, user_id) => {
  try {
    return await AuctionParticipant.findOrCreate({
      where: { user_id, auction_id }
    });
  } catch (err) {
    throw new Error(JSON.stringify({ message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏ –∫ –∞—É–∫—Ü–∏–æ–Ω—É', error: err.message }));
  }
};



exports.closeLotManually = async (lot_id) => {
  const t = await sequelize.transaction();

  try {
    const lot = await Lot.findByPk(lot_id, { transaction: t });
    if (!lot) throw new Error(JSON.stringify({ message: '–õ–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' }));

    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ pending-–∑–∞—è–≤–∫–∏
    const pendingOffers = await Offer.findAll({
      where: { lot_id, status: 'pending' },
      order: [['percent', 'DESC']],
      transaction: t
    });

    if (!pendingOffers.length) {
      lot.status = 'expired';
      await lot.save({ transaction: t });
      await t.commit();
      return { message: '–ù–µ—Ç –∑–∞—è–≤–æ–∫ –≤ —ç—Ç–æ–º –ª–æ—Ç–µ' };
    }

    // –ù–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ü–µ–Ω—Ç
    const maxPercent = pendingOffers[0].percent;

    // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –ª–∏–¥–µ—Ä–æ–≤
    const topOffers = pendingOffers.filter(o => o.percent === maxPercent);

    // –î–µ–ª–∏–º –æ–±—ä—ë–º –ª–æ—Ç–∞ –º–µ–∂–¥—É –Ω–∏–º–∏
    const share = lot.volume / topOffers.length;

    for (const offer of topOffers) {
      offer.status = 'accepted';
      await offer.save({ transaction: t });

      await Deal.create({
        auction_id: lot.auction_id,
        lot_id: lot.id,
        offer_id: offer.id,
        user_id: offer.user_id,
        percent: offer.percent,
        amount: share
      }, { transaction: t });
    }

    // –û—Å—Ç–∞–ª—å–Ω—ã–º –º–µ–Ω—è–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞ rejected
    const losers = pendingOffers.filter(o => o.percent < maxPercent);
    for (const offer of losers) {
      offer.status = 'rejected';
      await offer.save({ transaction: t });
    }

    // –ó–∞–∫—Ä—ã–≤–∞–µ–º –ª–æ—Ç
    lot.status = 'finished';
    await lot.save({ transaction: t });

    // –ï—Å–ª–∏ –≤—Å–µ –ª–æ—Ç—ã –∑–∞–∫—Ä—ã—Ç—ã ‚Äî –∑–∞–∫—Ä—ã–≤–∞–µ–º –∞—É–∫—Ü–∏–æ–Ω
    const openLots = await Lot.count({
      where: { auction_id: lot.auction_id, status: 'open' },
      transaction: t
    });
    if (openLots === 0) {
      await Auction.update(
        { status: 'finished' },
        { where: { id: lot.auction_id }, transaction: t }
      );
    }

    await t.commit();
    return { message: '–õ–æ—Ç –∑–∞–∫—Ä—ã—Ç' };

  } catch (error) {
    await t.rollback();
    throw new Error(JSON.stringify({
      message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä—É—á–Ω–æ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –ª–æ—Ç–∞',
      error: error.message
    }));
  }
};


exports.checkForOwnAuction = async (auction_id, user_id) => {
  try {
    const auction = await Auction.findOne({ where: { id: auction_id, user_id } });
    if(!auction) {
      return false
    }
    return true
  } catch (err) {
    throw new Error(JSON.stringify({ message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∞—É–∫—Ü–∏–æ–Ω–∞', error: err.message }));
  }
};

exports.approveParticipant = async (auction_id, user_id, initiator_id, status) => {
  try {
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä –ª–∏ —Ç–µ–∫—É—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    const auction = await Auction.findByPk(auction_id);
    if (!auction) {
      throw new Error('–ê—É–∫—Ü–∏–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω');
    }
    // if (auction.user_id !== initiator_id) {
    //   throw new Error('–£ –≤–∞—Å –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç –ø—Ä–∞–≤');
    // }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–ø–∏—Å–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞
    const participant = await AuctionParticipant.findOne({
      where: {
        auction_id,
        user_id,
      },
    });

    if (!participant) {
      throw new Error('–£—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω');
    }

    participant.status = status;
    await participant.save();

    return participant
  } catch (err) {
    throw new Error(JSON.stringify({
      message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–¥–æ–±—Ä–µ–Ω–∏–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞',
      error: err.message,
    }));
  }
};

exports.getAuctionReport = async (req, res) => {
  // –ù–∞—Ö–æ–¥–∏–º –∞—É–∫—Ü–∏–æ–Ω —Å –ª–æ—Ç–∞–º–∏, –æ—Ñ—Ñ–µ—Ä–∞–º–∏ –∏ —Å–¥–µ–ª–∫–∞–º–∏
  const { id } = req.params;
  const auction = await Auction.findByPk(id, {
    include: [
      {
        model: Lot,
        as: 'lots',
        include: [
          {
            model: Offer,
            as: 'offers',
            // where: { status: 'accepted' },
            include: [
              {
                model: User,
                as: 'user',
                include: [{ model: UserInfo, as: 'user_info' }]
              },
              {
                model: Deal,
                include: [
                  {
                    model: Offer,
                    include: [
                      {
                        model: User,
                        as: 'user',
                        include: [{ model: UserInfo, as: 'user_info' }]
                      }
                    ]
                  }
                ]
              }
            ]
          },
        ]
      },
      {
        model: AuctionParticipant,
        as: 'participants'
      }
    ]
  });

  if (!auction) {
    throw new Error('–ê—É–∫—Ü–∏–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω');
  }

  // –û–±—â–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
  const generalInfo = {
    date: auction.createdAt, // –∏–ª–∏ –¥—Ä—É–≥–æ–µ –ø–æ–ª–µ —Å –¥–∞—Ç–æ–π
    totalVolume: auction.lots.reduce((sum, lot) => sum + lot.volume, 0),
    participantsCount: auction.participants?.length || 0
  };

  // –í–µ–¥–æ–º–æ—Å—Ç—å –ø–æ—Å—Ç—É–ø–∏–≤—à–∏—Ö –∑–∞—è–≤–æ–∫
  const offersTable = auction.lots.flatMap(lot =>
    lot.offers.map(o => ({
      bank: o.user.user_info?.bank_name || o.user.name,
      lotId: lot.id,
      lotAsset: lot.asset,
      lotPercent: lot.percent,
      lotTermMonth: lot.term_month,
      depositAmount: o.volume,
      offerPercent: o.percent
    }))
  );

// –ò—Ç–æ–≥–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
const dealsTable = auction.lots.flatMap(lot =>
  (lot.offers || []).flatMap(offer =>
    (offer.Deal ? [{
      bank: offer.user?.user_info?.bank_name || offer.user?.name || '‚Äî',
      lotId: lot.id,
      lotAsset: lot.asset,
      lotPercent: lot.percent,
      lotTermMonth: lot.term_month,
      depositAmount: offer.Deal.amount,
      offerPercent: offer.percent
    }] : [])
  )
);

  return res.json({
    generalInfo,
    offersTable,
    dealsTable
  });
};